# 阶段

## **学习目标**

1. 了解常见的设计模式，选择 3、4 种进行深入了解，并在后续丰富组件库过程中进行实践
2. 了解前端组件设计原则，知道如何设计一个前端通用组件，并在后续实践

## **📚 学习内容(5d)**

1. 了解常见的设计模式(3、4 种即可)
   1. 按类型划分
      1. 创建型
         1. Constructor（构造器）
         2. Factory（工厂）
         3. Abstract（抽象）
         4. Prototype（原型）
         5. Singleton（单例）
         6. Builder（生成器）
      2. 结构型
         1. Decorator（装饰者）
         2. Facade（外观）
         3. Flyweight（享元）
         4. Adapter（适配器）
         5. Proxy（代理)
      3. 行为型
         1. Iterator（迭代器）
         2. Mediator（中介者）
         3. Observer（观察者）
         4. Visitor（访问者）
   2. 业务场景
      1. 代码封装
         1. 工厂模式
         2. 创建者模式
         3. 单例模式
         4. 原型模式
      2. 代码复用性
         1. 桥接模式
         2. 享元模式
         3. 模板方法模式
      3. 代码质量
         1. 策略/状态 模式
         2. 外观模式
         3. 迭代器模式
         4. 备忘录模式
      4. 框架源码里用于提升代码扩展性的模式
         1. 职责链模式
         2. 观察者模式
         3. 装饰器模式
         4. 适配器模式
2. 了解前端组件设计原则
3. 了解设计模式六大原则
   1. 单一职责原则（类和方法，接口）
   2. 开闭原则（扩展开放，修改关闭）
   3. 里氏替换原则（基类和子类之间的关系）
   4. 依赖倒置原则（依赖抽象接口，而不是具体对象）
   5. 接口隔离原则（接口按照功能细分）
   6. 迪米特法则（类与类之间的亲疏关系）

## **🍐 成果**

1. 个人博客文章
   1. 了解设计模式的应用场景
   2. 了解常见的设计模式(3、4 种)
   3. 前端组件设计原则
2. 后续在丰富组件库过程中有意识的应用所选择深入了解和实践的设计模式

## **👆🏻 进阶**

1. [精读设计模式](https://github.com/ascoders/weekly/tree/master/设计模式)
2. [前端组件设计原则](https://juejin.cn/post/6844903767108747278#heading-0)
   1. [原文](https://engineering.carsguide.com.au/front-end-component-design-principles-55c5963998c9)
3. [设计可靠 React 组件的 7 个原则](https://dmitripavlutin.com/7-architectural-attributes-of-a-reliable-react-component/)

## **📢 注意**

1. [推荐书籍: JavaScript 设计模式与开发实践](https://weread.qq.com/web/bookDetail/6bf3215071a123016bf0b74)

## **资料参考**

1. [代码封装与设计模式](https://juejin.cn/post/6844904165836062734#heading-3)
2. [代码复用性与设计模式](https://juejin.cn/post/6844904168017100813)
3. [代码质量与设计模式](https://juejin.cn/post/6844904180885225486)
4. [框架源码与设计模式](https://juejin.cn/post/6844904174451179528)
5. [工作中用到的设计模式](https://juejin.cn/post/7023536216138055716)

# 设计模式

## 策略模式

策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。策略模式针对一组算法，将每个算法封装带具有共同结构的独立的类中，从而使得它们可以相互替换。

> 假设你跟不同性格类型的小姐姐约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去逛街买买买最合适。当然，目的都是为了得到小姐姐的芳心，请看电影、吃小吃、逛街就是不同的策略。



## 责任链模式

> 责任链模式为请求创建了一个接收者对象的链。执行链上有多个对象节点，每个对象节点都有机会（条件匹配）处理请求事务，如果某个对象节点处理完了，就可以根据实际业务需求传递给下一个节点继续处理或者返回处理完毕。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。

责任链模式实际上是一种处理请求的模式，它让多个处理器（对象节点）都有机会处理该请求，直到其中某个处理成功为止。



## 模板方法模式

定义一个操作中的算法的骨架流程，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。它的核心思想是：定义一个操作的一系列步骤，对于某些暂时确定不下来的步骤，就留给子类去实现，这样不同的子类就可以定义出不同的步骤。



## 观察者模式

> 观察者模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被完成业务的更新。

观察者模式属于行为模式，一个对象（被观察者）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。它的成员主要是**观察者和被观察者**。

**被观察者：**目标对象，状态发生改变时，将通知所有的观察者；

**观察者：**接受被观察者的状态变化通知，执行预先定义的业务。



## 工厂模式

工厂模式一般配合策略模式一起使用。用来去优化大量的`if...else...`或`switch...case...`条件语句。



## 原型模式

Prototype（原型模式）属于创建型模式，既不是工厂也不是直接 New，而是以拷贝的方式创建对象。

**意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。**

原型实例就是被选为拷贝模板的那个对象，一般来说，原型模式的拷贝建议用**深拷贝**，毕竟新对象最好不要影响到旧对象，但是在深拷贝性能问题较大的情况下，可以考虑深浅拷贝结合，也就是将在新对象中不会修改的数据使用浅拷贝，可能被修改的数据使用深拷贝。





## 单例模式

**定义：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。

**场景：**单击登录按钮出现浮窗，无论单击多少次登录按钮，浮窗只会被创建一次，那么这个登录浮窗就适合用单例模式来创建。

### 实现单例模式

思路：用一个变量来标志当前是否已经为某个类创建过对象，如果是，则在下次获取该类的实例时，直接返回之前创建的对象。

#### 简单实现

```js
        var Singleton = function( name ){
            this.name = name;
            this.instance = null;
        };

        Singleton.prototype.getName = function(){
            alert ( this.name );
        };

        Singleton.getInstance = function( name ){
            if ( ! this.instance ){
              this.instance = new Singleton( name );
            }
            return this.instance;
        };

        var a = Singleton.getInstance( 'sven1' );
        var b = Singleton.getInstance( 'sven2' );

        alert ( a === b );    // true
```

#### 透明的单例模式

在页面中创建唯一的 div 节点：

```js
        var CreateDiv = (function(){

            var instance;

            var CreateDiv = function( html ){
              if ( instance ){
                  return instance;
              }
              this.html = html;
              this.init();
              return instance = this;
          };

          CreateDiv.prototype.init = function(){
              var div = document.createElement( 'div' );
              div.innerHTML = this.html;
              document.body.appendChild( div );
          };

          return CreateDiv;

        })();

        var a = new CreateDiv( 'sven1' );
        var b = new CreateDiv( 'sven2' );

        alert ( a === b );     // true
```

缺点：不符合“单一职责原则”。

#### 用代理实现单例模式

```js
        var CreateDiv = function( html ){
            this.html = html;
            this.init();
        };

        CreateDiv.prototype.init = function(){
            var div = document.createElement( 'div' );
            div.innerHTML = this.html;
            document.body.appendChild( div );
        };
```

引入代理类 proxySingletonCreateD ，把负责管理单例的逻辑移到代理类中：

```js
        var ProxySingletonCreateDiv = (function(){

            var instance;
            return function( html ){
              if ( !instance ){
                  instance = new CreateDiv( html );
              }

              return instance;
            }

        })();

        var a = new ProxySingletonCreateDiv( 'sven1' );
        var b = new ProxySingletonCreateDiv( 'sven2' );

        alert ( a === b );
```

### 惰性单例

惰性单例 指的是在需要的时候才创建对象实例。



