# 参考

<img src="file:///C:\Users\玛的巴卡\AppData\Local\Temp\SGPicFaceTpBq\52192\1ED77993.png" alt="img" style="zoom:33%;" />[最全的手写JS面试题](https://juejin.cn/post/6968713283884974088)

## 基础篇

1. [compose](https://github.com/qianlongo/fe-handwriting/blob/master/1.compose.js)
2. [模拟instanceOf](https://github.com/qianlongo/fe-handwriting/blob/master/2.instanceOf.js)
3. [多维数组拍平](https://github.com/qianlongo/fe-handwriting/blob/master/3.flat.js)
4. [setTimeout模拟setInterval](https://github.com/qianlongo/fe-handwriting/blob/master/4.setTimeout-interval.js)
5. [setInterval模拟setTimeout](https://github.com/qianlongo/fe-handwriting/blob/master/5.setInterval-timeout.js)
6. [手写call](https://github.com/qianlongo/fe-handwriting/blob/master/6.call.js)
7. [手写aplly](https://github.com/qianlongo/fe-handwriting/blob/master/7.apply.js)
8. [数组去重](https://github.com/qianlongo/fe-handwriting/blob/master/8.uniqueArray.js)
9. [实现一个Promise.all](https://github.com/qianlongo/fe-handwriting/blob/master/9.promise.all.js)
10. [实现一个Promise.race](https://github.com/qianlongo/fe-handwriting/blob/master/10.promise.race.js)
11. [手写Promise](https://github.com/qianlongo/fe-handwriting/blob/master/11.promise.js)
12. [正则模拟实现trim方法](https://github.com/qianlongo/fe-handwriting/blob/master/12.trim.js)
13. [手机号 3-3-4分割](https://github.com/qianlongo/fe-handwriting/blob/master/13.mobile-334.js)
14. [手写一个new](https://github.com/qianlongo/fe-handwriting/blob/master/14.new.js)
15. [手写一个深拷贝](https://github.com/qianlongo/fe-handwriting/blob/master/15.deepClone.js)
16. [千分位格式化数字](https://github.com/qianlongo/fe-handwriting/blob/master/27.formatPrice.js)
17. [Object.create](https://github.com/qianlongo/fe-handwriting/blob/master/44.Object.create.js)
18. [isCyclic判断循环引用](https://github.com/qianlongo/fe-handwriting/blob/master/51.js)
19. [手写JSON.stringify](https://github.com/qianlongo/fe-handwriting/blob/master/50.JSON.stringify.js)
20. [并行限制的Promise](https://github.com/qianlongo/fe-handwriting/blob/master/49.scheduler.js)
21. [判断数据类型](https://github.com/qianlongo/fe-handwriting/blob/master/46.getType.js)
22. [发布订阅](https://github.com/qianlongo/fe-handwriting/blob/master/45.EventEmitter.js)
23. [debounce](https://github.com/qianlongo/fe-handwriting/blob/master/52.debounce.html)
24. [throttle](https://github.com/qianlongo/fe-handwriting/blob/master/53.throttle.js)
25. [bind](https://github.com/qianlongo/fe-handwriting/blob/master/55.bind.js)
26. [curry](https://github.com/qianlongo/fe-handwriting/blob/master/54.curry.js)
27. [templateRender](https://github.com/qianlongo/fe-handwriting/blob/master/56.templateRender.js)
28. [dom2json](https://github.com/qianlongo/fe-handwriting/blob/master/57.dom2json.html)
29. [list2tree](https://github.com/qianlongo/fe-handwriting/blob/master/59.list2tree.js)
30. [tree2list](https://github.com/qianlongo/fe-handwriting/blob/master/60.tree2list.js)
31. [sleep](https://github.com/qianlongo/fe-handwriting/blob/master/61.sleep.js)
32. [sum](https://github.com/qianlongo/fe-handwriting/blob/master/63.sum.js)
33. [findCommonParent](https://github.com/qianlongo/fe-handwriting/blob/master/68.findCommonParent.html)
34. [expireStorage](https://github.com/qianlongo/fe-handwriting/blob/master/69.expireStorage.js)
35. [reduceMap](https://github.com/qianlongo/fe-handwriting/blob/master/70.reduceMap.js)
36. [firstPromise](https://github.com/qianlongo/fe-handwriting/blob/master/71.firstPromise.js)

## 排序篇

1. [快速排序](https://github.com/qianlongo/fe-handwriting/blob/master/17.quick-sort.js)
2. [冒泡排序](https://github.com/qianlongo/fe-handwriting/blob/master/18.bubble-sort.js)
3. [选择排序](https://github.com/qianlongo/fe-handwriting/blob/master/19.select-sort.js)
4. [插入排序](https://github.com/qianlongo/fe-handwriting/blob/master/20.insert-sort.js)

## 算法篇

### 数组

1. [两数之和](https://github.com/qianlongo/fe-handwriting/blob/master/21.two-sum.js)
2. [合并两个有序数组](https://github.com/qianlongo/fe-handwriting/blob/master/22.merge-sorted-array.js)
3. [两个数组的交集](https://github.com/qianlongo/fe-handwriting/blob/master/23.intersection.js)
4. [删除有序数组的重复项](https://github.com/qianlongo/fe-handwriting/blob/master/28.remove-duplicates.js)
5. [两个数组之间的交集2](https://github.com/qianlongo/fe-handwriting/blob/master/29.intersect2.js)
6. [只出现一次的数字](https://github.com/qianlongo/fe-handwriting/blob/master/30.singleNumber.js)
7. [判断数组中是否有重复项](https://github.com/qianlongo/fe-handwriting/blob/master/31.contains-duplicate.js)
8. [移动零](https://github.com/qianlongo/fe-handwriting/blob/master/32.move-zeroes.js)
9. [二分查找](https://github.com/qianlongo/fe-handwriting/blob/master/41.hafl-search.js)
10. [搜索插入位置](https://github.com/qianlongo/fe-handwriting/blob/master/42.search-insert.js)
11. [724. 寻找数组的中心下标](https://github.com/qianlongo/fe-handwriting/blob/master/43.pivot-index.js)
12. [LRU最近最少使用](https://github.com/qianlongo/fe-handwriting/blob/master/48.LRU2.js)
13. [菲波那切数列](https://github.com/qianlongo/fe-handwriting/blob/master/62.fib.js)
14. [有效的括号](https://github.com/qianlongo/fe-handwriting/blob/master/67.validParentheses.js)

### 字符串

1. [验证回文串](https://github.com/qianlongo/fe-handwriting/blob/master/24.valid-palindrome.js)
2. [删除一个字符串，是否能成为回文](https://github.com/qianlongo/fe-handwriting/blob/master/25.valid-palindrome2.js)
3. [添加与搜索单词 - 数据结构设计](https://github.com/qianlongo/fe-handwriting/blob/master/26.word-dictionary.js)
4. [反转字符串](https://github.com/qianlongo/fe-handwriting/blob/master/33.reverse-string.js)
5. [字符串中的第一个唯一字符](https://github.com/qianlongo/fe-handwriting/blob/master/34.first-uniq-char.js)
6. [有效的字母异位词](https://github.com/qianlongo/fe-handwriting/blob/master/35.is-anagram.js)
7. [字符串转数字](https://github.com/qianlongo/fe-handwriting/blob/master/36.my-atoi.js)
8. [整数反转](https://github.com/qianlongo/fe-handwriting/blob/master/37.reverse-num.js)
9. [实现 strStr() 函数。](https://github.com/qianlongo/fe-handwriting/blob/m◊aster/38.str-str.js)
10. [最长公共前缀](https://github.com/qianlongo/fe-handwriting/blob/master/39.longest-common-prefix.js)
11. [比较版本号](https://github.com/qianlongo/fe-handwriting/blob/master/40.compare-version.js)

### 链表

1. [奇偶链表](https://github.com/qianlongo/fe-handwriting/blob/master/16.odd-even-linked-list.js)

# 手写题

## 手写call、apply、bind

### call

#### call都做了什么

```javascript
function sayWord() {
  var talk = [this.name, 'say', this.word].join(' ');
  console.log(talk);
}

var bottle = {
  name: 'bottle', 
  word: 'hello'
};

// 使用 call 将 bottle 传递为 sayWord 的 this
sayWord.call(bottle); 
// bottle say hello
```

call主要实现了两个功能：

- 改变函数的this指向
- 执行函数

#### 实现

实现call主要有三步：

1. 将函数设置为对象的属性
2. 执行函数
3. 删除添加的这个属性

```javascript
Function.prototype.call = function(context){
    // context为null和undefined的this值会自动指向全局对象（浏览器中是window对象）
    // context为原始值的this会指向该原始值的自动包装对象（用Object()转换）
    context = context ? Object(context) : window;
    // 给context添加一个fn属性，this指向了调用call的函数对象，把调用call的函数保存在fn中执行了
    context.fn = this;
    // 接收剩余的参数
    let args = [...arguments].slice(1);
    // 执行该函数
    let result = context.fn(...args);
    // 删除该属性
    delete context.fn;
    return result;
}
```

### apply

apply和call之间唯一的区别就是：call接受一个参数列表，而apply接受带有一个类数组对象（数组）。

```javascript
Function.prototype.apply = function(context, arr){
    // context为null和undefined的this值会自动指向全局对象（浏览器中是window对象）
    // context为原始值的this会指向该原始值的自动包装对象（用Object()转换）
    context = context ? Object(context) : window;
    context.fn = this;
    let result;
    // 判断数组参数并执行函数
    if(!arr){
        result = context.fn();
    } else{
        result = context.fn(...arr);
    }
    // 删除该属性
    delete context.fn;
    return result;
}
```

### bind

#### 特征

call、apply是立即执行函数，bind则是返回一个绑定上下文的函数。

```javascript
let value = 2;
let foo = {
    value: 1
};
function bar(name, age){
    return {
        value: this.value,
        name: name,
        age: age
    }
}
bar.call(foo, 'Jack', 20);
// {value: 1, name: "Jack", age: 20}

let bindFoo1 = bar.bind(foo, 'Rose', 18);
bindFoo1();
// {value: 1, name: "Rose", age: 18}

let bindFoo2 = bar.bind(foo, 'Rose');
bindFoo2(18);
// {value: 1, name: "Rose", age: 18}
```

从上述看出bind主要有一下特征：

1. 指定this
2. 传入参数列表
3. 返回一个新的函数
4. 柯里化

此外bind还有一个特征：

5. 一个绑定函数也能使用new操作符创建对象：这种行为就像是把原函数当做构造器，提供的this值被忽略，同时调用时的参数被提供给模拟函数。如下：

```javascript
let value = 2;
let foo = {
    value: 1
};
function bar(name, age) {
    this.habit = 'shopping';
    console.log(this.value);
    console.log(name);
    console.log(age);
}
bar.prototype.friend = 'kevin';

let bindFoo = bar.bind(foo, 'Jack');
let obj = new bindFoo(20);
// undefined
// Jack
// 20

obj.habit;
// shopping

obj.friend;
// kevin
```

通过new生成了一个新的对象，此时this的指向是obj。

#### 实现

```javascript
Function.prototype.bind = function(context){
    if (typeof this !== 'function') {
        throw new Error('Function.prototype.bind - what is trying to be bound is not callable');
    }
    var self = this;
    var args = [...arguments].slice(1);
    // 创建一个空对象
    var fNOP = function(){};
    // 返回一个函数
    var fBound = function() {
        // 获取bind返回函数的参数
        var bindArgs = [...arguments];
        // 同传入参数合并成一个参数数组，并作为self.apply()的第二个参数
        /**
         * 用 instanceof 来判断绑定函数 self 的原型是否在实例的原型链上：
         * 1. 使用 new 运算符作为构造函数调用时，this 指向实例
         *    因为我们在下面通过`fBound.prototype = this.prototype;`修改了 fBound 的原型为绑定函数的原型，所以此时结果为 true，this 指向实例。
         * 2. 正常作为普通函数调用时，this 指向 window，此时结果为 false，this 指向绑定的 context；
         */
        return self.apply(this instanceof self ? this : context, args.concat(bindArgs));
    }
    // 让返回函数的原型指向绑定函数的原型（这样实例就可以继承函数的原型）
    // 使用空函数作为中间变量来维护原型关系，避免让fBound.prototype和this.prototype指向同一个原型对象
    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}
```

https://juejin.cn/post/7158009281735262239

## 深拷贝

没有考虑循环引用的情况：

```javascript
const copyObj = (obj={}) => {
    let newObj = null;
    if (typeof obj == 'object' && obj !== null) {
        newObj = obj instanceof Array ? [] : {};
        for (const i in obj) {
            newObj[i] = copyObj(obj[i]);
        }
    } else {
        newObj = obj;
    }
    return newObj;
}
```

## Promise静态方法实现

### Promise.all()

Promise.all() 方法用于将多个Promise实例包装成一个新的Promise实例，

举个栗子，p的最终状态由p1、p2、p3决定：

```javascript
const p = Promise.all([p1, p2, p3])
```

- 当状态都变成fullfilled的时候，p的状态变为fullfilled，返回值组成一个数组传递给P的回调函数；
- 当其中有一个被rejected，p的状态就变成rejected，返回值为第一个rejected的实例返回值；

**实现：**

```javascript
Promise.myAll = (promises)=>{
    return new Promise((rs, rj)=>{
        let count = 0;
        let result = [];
        const len = promises.length;
        if (len===0) {
            return rs([]);
        }
        promises.forEach((element, i) => {
            Promise.resolve(element).then(res =>{
                count+=1;
                result[i] = res;
                if (count === len) {
                    rs(result);
                }
            }).catch(rj)
        });
    })
}
```

### Promise.allSettled()

Promise.allSettled() 方法接受一个数组作为参数，只有等到数组的所有 Promise 对象都发生状态变更，返回的 Promise 对象状态才会发生变更，一旦发生状态变更，状态总是 fullfilled，不会变成 rejected。

```javascript
const p1 = Promise.resolve(1)
const p2 = new Promise((resolve) => {
  setTimeout(() => resolve(2), 1000)
})
const p3 = new Promise((resolve) => {
  setTimeout(() => resolve(3), 3000)
})

const p4 = Promise.reject('err4')
const p5 = Promise.reject('err5')

const p12 = Promise.allSettled([ p1, p2, p4 ])
	.then((res) => console.log(JSON.stringify(res, null,  2)))
        
// 输出 
/*
[
  {
    "status": "fulfilled",
    "value": 1
  },
  {
    "status": "fulfilled",
    "value": 2
  },
  {
    "status": "rejected",
    "reason": "err4"
  }
]
*/
```

**实现：**

```javascript
Promise.myAllSettled = (promises)=>{
    return new Promise((res, rej)=>{
        let count = 0;
        let result = [];
        let length = promises.length;
        promises.forEach((element, i)=>{
            Promise.resolve(element).then((rs)=>{
                count+=1;
                result[i] = {
                    status: 'fulfilled',
                    value: rs
                }
                if (count === length) {
                    res(result)
                }
            }).catch((err)=>{
                count+=1;
                result[i] = {
                    status: 'rejected',
                    value: err
                }
                if (count === length) {
                    res(result)
                }
            })
        })
    })
}
```

### Promise.race()

Promise.race() 方法 同样是将多个Promise实例，包装成一个新的Promise实例。

```javascript
const p = Promise.race([p1, p2, p3])
```

只要p1\p2\p3中有一个实例率先改变状态，p的状态就跟着改变。率先改变的Promise实例的返回值传递给p的回调函数。

**实现：**

```javascript
Promise.myRace = (promises)=>{
    return new Promise((res, rej)=>{
        promises.forEach((element)=>{
            // 对element进行一次包装，防止非promise对象
            // 并且对其进行监听，将我们自己返回的promise对象的resolve、reject传递给element，哪个先改变状态，我们返回的promise也将会是什么状态
            Promise.resolve(element).then(res).catch(rej)
        })
    })
}
```

## sleep函数

`sleep函数`作用是让线程休眠，等到指定时间再重新唤起。

- 利用伪死循环阻塞主线程
- 定时器实现
- promise异步处理
- generator实现
- async/await

```javascript
// 1. 利用伪死循环阻塞主线程
function sleep(delay){
    var start = (new Date()).getTime();
    while ((new Date()).getTime() - start < delay) {
        continue;
    }
}
function test(){
    console.log('111');
    sleep(2000);
    console.log('222');
}
test();
// 2. 定时器实现
function sleep1(ms, callback){
    setTimeout(callback, ms);
}
sleep1(1000, ()=>{
    console.log('111');
})

// 3.异步处理
const sleep2 = time=>{
    return new Promise(reslove=>{
        setTimeout(reslove, time)
    })
}
sleep2(1000).then(()=>{
    console.log('111');
})

// 4.generator实现
function * sleep3(time){
    yield new Promise(reslove=>{
        setTimeout(reslove, time)
    })
}
sleep3(1000).next().value.then(()=>{
    console.log('111');
})

// 5.async/await
function sleep4(time){
    return new Promise(reslove=>{
        setTimeout(reslove, time)
    })
}
async function output(){
    let out = await sleep4(1000);
    console.log('111');
    return out;
}
output();
```

# 算法

## 递归爆栈与解决方案

https://www.jianshu.com/p/0723efc1e6f6

### 原因 

函数caller运行时，调用其他函数called，js会在调用栈中新开一个调用帧存储作用域和上下文信息，而caller的调用帧信心仍需要保存。而内存中调用栈存储信息有限，递归的情况下，如果递归层次过深会导致调用栈耗光而引起stack overflow —— 栈溢出。

**举个栗子：**

```javascript
function f(n){
    if(n===0||n===1){
    return n
  }else 
    return f(n-1)+f(n-2)
}
```

f(100)时浏览器就会卡死。

**计算JS调用栈的最深层级大小：**

```javascript
function computeMaxCallStackSize() {
    try {
      return 1 + computeMaxCallStackSize();
    } catch (e) {
      // Call stack overflow
      return 1;
    }
}
computeMaxCallStackSize()
// 12531
```

### 解决方案

#### 1. 改为尾调优化

思路：使用两个临时变量存储上一个值，和上上个值；

```javascript
function fTail(n, ac1=0, ac2=1){
    if(n===0){
    return ac1
  }else
      return fTail(n-1, ac2, ac1+ac2)
}

fTail(100)
// 354224848179262000000
fTail(1000)
// 4.346655768693743e+208
fTail(2000)
// Infinity
```

尾调优化主要有两点问题，导致它的提案仍没有完全通过，浏览器的支持也不统一：

- 在引擎层面进行尾调优化是一个隐式行为，如果代码存在死循环尾递归调用，可能因为优化后没有爆栈错误提示而无法被程序员察觉；
- 优化后，调用堆栈信息会丢失，造成调试困难；

#### 2. 改用循环重写??

所有递归都可以转化为循环编写

思路：Fibonacci数列的实现使用循环

```javascript
function fLoop(n, ac1 = 0, ac2 = 1) {  
  while (n--) {
    [ac1, ac2] = [ac2, ac1 + ac2]
  }
  return ac1
}
// 运行看看
fLoop(1000)
// 4.346655768693743e+208
fLoop(10000)
// Infinity
fLoop(100000)
// Infinity
```

